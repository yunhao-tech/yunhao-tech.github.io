<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客建站记录</title>
    <url>/posts/bc4240cc/</url>
    <content><![CDATA[<h1 id="第一个博客网站"><a href="#第一个博客网站" class="headerlink" title="第一个博客网站"></a>第一个博客网站</h1><p>2021年的时候，我跟着<a href="https://www.bilibili.com/video/BV1cW411A7Jx">手把手教你搭建属于自己的hexo+github博客</a>这个教程，用 <code>node, git, hexo</code> 第一次搭建了博客网站。那次用的主题是 <code>Next</code>，总感觉不太好看，后来就慢慢搁置了。</p>
<p>最近重新鼓捣配置了 <code>butterfly</code> 主题，算是初步满足了我对个人博客的审美要求。还有很多功能没有部署，之后慢慢摸索吧，先记录一下这次优化的 Roadmap.</p>
<h1 id="优化流程"><a href="#优化流程" class="headerlink" title="优化流程"></a>优化流程</h1><p>Butterfly 主题的引导很到位，文档详细，功能很全：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 文档</a>。一些基本配置，如导航栏、侧边栏、页脚等，跟着流程走完即可。在此基础上，我借鉴了一些博主的优化经验和教程。</p>
<h2 id="生成唯一永久文章链接"><a href="#生成唯一永久文章链接" class="headerlink" title="生成唯一永久文章链接"></a>生成唯一永久文章链接</h2><p>hexo 文章链接依赖于文章标题，文章标题是中文时，链接很不简洁；修改文章标题后，文章的链接也会变化，非常不方便。可以利用 <code>Hexo-abbrlink</code> 插件为每篇文章生成唯一永久链接：<a href="https://www.jianshu.com/p/c7de2ae59975">Hexo-abbrlink生成唯一永久文章链接</a></p>
<h2 id="Twikoo-评论板块"><a href="#Twikoo-评论板块" class="headerlink" title="Twikoo 评论板块"></a>Twikoo 评论板块</h2><p>给博客添加留言功能，并且配置了邮件提醒功能。每当有新的留言和回复时，博主和被回复人就能收到邮件。</p>
<ul>
<li><a href="https://www.nickxu.top/2022/02/19/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89Twikoo-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">Twikoo 评论系统</a>：这篇博客手把手介绍了如何配置 MongoDB 数据库、使用 Vercel 运行云函数、开启 Twikoo 评论功能；</li>
<li><a href="https://west2.cn/2315.html">Gmail邮箱开启 SMTP 服务</a>：如果要用 Gmail 的邮件发送服务，需要开启 SMTP。这篇文章教你如何配置。当然也可以用 QQ 邮箱或者其他邮箱，在网上有很多教程。</li>
<li><a href="https://blog.zhheo.com/p/169a1abb.html#%E9%82%AE%E4%BB%B6%E6%A0%B7%E5%BC%8F">Twikoo评论回复邮件模板</a>：我们可以自定义 Twikoo 的邮件回复模板。</li>
</ul>
<h2 id="RSS-订阅"><a href="#RSS-订阅" class="headerlink" title="RSS 订阅"></a>RSS 订阅</h2><p>利用插件 <code>hexo-generator-feed</code>，为博客生成一份 RSS 订阅地址，订阅该地址的用户将在每次博客更新时收到推送。参考：<a href="https://zhangshier.vip/posts/41646/#RSS%E8%AE%A2%E9%98%85">Hexo 博客搭建 - RSS 订阅</a></p>
<h2 id="首页文章置顶"><a href="#首页文章置顶" class="headerlink" title="首页文章置顶"></a>首页文章置顶</h2><p><a href="https://zfe.space/post/hexo-swiper.html">hexo-swiper 文章置顶插件</a>：利用 <code>hexo-swiper-bar</code> 插件，节选 N 篇文章置顶，并循环播放。</p>
<h2 id="版权美化"><a href="#版权美化" class="headerlink" title="版权美化"></a>版权美化</h2><p><a href="https://www.imcharon.com/117/">butterfly版权美化教程</a>：对 Butterfly 的版权模块进行美化。</p>
<h2 id="搜索引擎收录"><a href="#搜索引擎收录" class="headerlink" title="搜索引擎收录"></a>搜索引擎收录</h2><p><a href="https://zhangshier.vip/posts/41646/#%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95">谷歌以及 Bing 收录</a></p>
<h2 id="博客源文件备份"><a href="#博客源文件备份" class="headerlink" title="博客源文件备份"></a>博客源文件备份</h2><p>要知道，Github 上 <code>username.github.io</code> 仓库里仅仅是 Hexo 编译后的文件，专门用来生成网页，不包含主题配置、markdown 源文件。如何把源文件进行备份呢？<a href="https://www.zhihu.com/question/21193762/answer/489124966">使用hexo，如果换了电脑怎么更新博客？</a> 这篇回答提供了一个思路：在 Github <code>username.github.io</code> 仓库里新建一个分支，专门用来存储源文件。</p>
<h1 id="实用网站"><a href="#实用网站" class="headerlink" title="实用网站"></a>实用网站</h1><ul>
<li><a href="https://sm.ms/">SM MS 图床网站</a>：允许我们为本地图片生成 URL 链接，可以作为博客图片的云上存储。免费限额：5GB</li>
<li><a href="https://fontawesome.com/icons">图标网站</a>：图标网站，其中大多数图标受 Butterfly 支持，可以为导航栏等处选择喜欢的图标</li>
<li><a href="https://webgradients.com/">渐变色</a>：收录了很多渐变色，提供 CSS 代码，在配置背景图、题图时可以用到。</li>
</ul>
<h1 id="Bug-修复"><a href="#Bug-修复" class="headerlink" title="Bug 修复"></a>Bug 修复</h1><ol>
<li><p>Hexo 更改主题后启动服务器，界面显示如下错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends includes&#x2F;layout.pug block content include includes&#x2F;recent-posts.pug include includes&#x2F;partial</span><br></pre></td></tr></table></figure>
<p>解决方案<a href="https://blog.csdn.net/weixin_44318830/article/details/104884936">看这里</a></p>
</li>
<li><p>使用 abbrlink 后，点击不同的文章都会跳转到同一个文章页面<br>前面提到，abbrlink 为每篇文章生成唯一的链接。我这里失误，在 <code>Front-matter</code> 那里把两篇文章的 abbrlink 修改成了一样的。导致它们的链接是相同的，自然也就无法区分了。</p>
</li>
</ol>
<p>注意：不要在文章 <code>Front-matter</code> 指定、修改 abbrlink，它是自动生成并添加到那里的。</p>
<h1 id="博客创作流程："><a href="#博客创作流程：" class="headerlink" title="博客创作流程："></a>博客创作流程：</h1><p>这一部分是备忘录，Mark 一下创作博客的流程和注意事项。</p>
<ol>
<li>在博客根目录下运行 cmd，运行 <code>hexo new post &lt;title&gt;</code>，生成 <code>title.md</code> 新文件。<br>注：每篇文章的 front-matter 一般包含 title, tags, categories等元素。<br>Example:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: </span><br><span class="line">tags:</span><br><span class="line">  - tag1</span><br><span class="line">  - tag2 //多标签</span><br><span class="line">categories: </span><br><span class="line">cover: </span><br><span class="line">description: </span><br></pre></td></tr></table></figure></li>
<li>创作完成后，在博客根目录下执行以下命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g //生成静态网页</span><br><span class="line">hexo s //在本地预览</span><br></pre></td></tr></table></figure>
可以一条龙服务：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
大家喜欢把它们叫做“hexo一键三连”。最后执行 <code>hexo d</code>，把生成的静态网页推送到 GitHub.</li>
</ol>
<ol start="3">
<li>最后不要忘记把源文件备份一下（假设 Github 仓库的默认分支为源文件所在分支）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Your commit message&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
更多细节参考：<a href="http://yearito.cn/posts/hexo-writing-skills.html">Hexo 搭建个人博客系列：写作技巧篇</a></li>
</ol>
]]></content>
      <categories>
        <category>博客个性化</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常见数据结构与Python实现</title>
    <url>/posts/df714f20/</url>
    <content><![CDATA[<p>学习Python之后，仿佛栈、堆、队列等数据结构都离我远去了，这是因为Python以其高效的 list, dict, set 很大程度上代替了它们。但还是有必要梳理一下这些数据结构，了解它们的基本概念，以及在 Python 中如何实现。</p>
<p>有一点必须说明，Python 内置的 list, dict, set 数据结构与红黑树等各有优劣。单纯地评价好坏没有意义，必须结合应用场景灵活选择，详见倒数第二节的讨论。</p>
<h1 id="（非）线性数据结构"><a href="#（非）线性数据结构" class="headerlink" title="（非）线性数据结构"></a>（非）线性数据结构</h1><p>线性数据结构是有序数据项的集合，其中每个数据项都有<strong>唯一</strong>的前驱和后继（除了第一个没有前驱、最后一个没有后继）。</p>
<p>不同线性结构的区别关键在于数据项增减的方式：有的只允许数据从一端添加；有的则允许数据量从两端或中间添加。<br>常见的线性结构：<strong>栈（stack），队列（queue），链表（linked list）</strong>。</p>
<p>非线性数据结构主要包括：<strong>树（tree）和图（graph）</strong>.</p>
<h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h1><p>数据的加入和移除都只发生在同一端（栈顶），另一端叫做栈底。</p>
<p>栈的进出规则遵循：<strong>后进先出</strong>（Last in First out, <strong>LIFO</strong>），越晚入栈的越早出栈。生活中的例子：一摞书、网页的后退操作、Undo操作。</p>
<h2 id="Python-中的实现"><a href="#Python-中的实现" class="headerlink" title="Python 中的实现"></a>Python 中的实现</h2><p>Python 的内置库实现了栈这种数据结构：<code>queue.LifoQueue()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">stack = queue.LifoQueue()</span><br><span class="line"></span><br><span class="line">stack.put(<span class="number">5</span>)             <span class="comment"># 对应 Push 操作，把数据压入栈</span></span><br><span class="line">stack.get()              <span class="comment"># 对应 pop 操作，数据出栈</span></span><br></pre></td></tr></table></figure>
<p>Ps: 当然也可以自己构建栈结构。一种思路是：利用 List，把 List 的末端当作栈顶，元素的进出只能通过末端，此时 push/pop 的复杂度都是 O(1)。当然也可以把首端当作栈顶，但这样 push/pop 的复杂度都是 O(n)。下面是实现的样例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myStack</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.items = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 查看栈顶的数据，并不取出</span></span><br><span class="line">        <span class="keyword">return</span> self.items[-<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>
<h2 id="栈的应用：括号匹配"><a href="#栈的应用：括号匹配" class="headerlink" title="栈的应用：括号匹配"></a>栈的应用：括号匹配</h2><p>问题描述：括号的使用要平衡，每个开括号要恰好对应一个闭括号；每对开闭括号要正确嵌套。识别括号是否匹配，是编程语言编译器的基础算法。</p>
<p>注意到，最早的开括号应该匹配最后的闭括号，这种次序反转正好符合栈 LIFO 的特点。具体来说，从左到右扫描，遇到左括号就压入栈；遇到右括号就取出栈顶的元素：如果是左括号，继续扫描；如果是右括号，直接返回 False。扫描完毕后，如果栈内还有元素，返回False，否则返回 True</p>
<p>对于小括号、中括号、大括号混杂的情况，思路也是一样。遇到闭括号时，取出栈顶元素，判断是否是同一类型开括号即可。样例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matches</span>(<span class="params"><span class="built_in">open</span>, close</span>):</span></span><br><span class="line"><span class="comment">############### 通过比较下标来判断是否为同一类型的括号，思路值得学习 ###############</span></span><br><span class="line">    opens = <span class="string">&#x27;([&#123;&#x27;</span></span><br><span class="line">    closes = <span class="string">&#x27;)]&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> opens.index(<span class="built_in">open</span>) == closes.index(close)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span>(<span class="params">symbolString</span>):</span></span><br><span class="line">    s = queue.LifoQueue()</span><br><span class="line">    balanced = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> symbol <span class="keyword">in</span> symbolString:</span><br><span class="line">        <span class="keyword">if</span> symbol <span class="keyword">in</span> <span class="string">&#x27;([&#123;&#x27;</span>:</span><br><span class="line">            s.put(symbol)</span><br><span class="line">        <span class="keyword">elif</span> s.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            top = s.get()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> matches(top, symbol):</span><br><span class="line">                balanced = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> (balanced <span class="keyword">and</span> s.empty())</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a><strong>队列 Queue</strong></h1><p>新数据的添加总发生在一端（尾端），而数据的移除总发生在另一端（首端）。队列遵循<strong>先进先出</strong>原则（First in first out, <strong>FIFO</strong>)。生活中的例子：排队、KTV点歌</p>
<h2 id="Python-中的实现-1"><a href="#Python-中的实现-1" class="headerlink" title="Python 中的实现"></a>Python 中的实现</h2><p><strong><code>queue.Queue()</code></strong>: API 详见 <a href="https://docs.python.org/3/library/queue.html">queue — A synchronized queue class</a></p>
<p>它的 <code>put</code> 和 <code>get</code> 方法都可以阻塞，因此它可以用于多线程之间、线程安全的通信。参考视频：<a href="https://www.bilibili.com/video/BV1bK411A7tV/?p=5">Python爬虫——生产者、消费者之间的多线程通信</a></p>
<blockquote>
<p>put: block if necessary until a free slot is available.</p>
<p>get: block if necessary until an item is available.</p>
</blockquote>
<hr>
<h1 id="优先队列-PriorityQueue"><a href="#优先队列-PriorityQueue" class="headerlink" title="优先队列 PriorityQueue"></a><strong>优先队列 PriorityQueue</strong></h1><p>优先队列与队列的区别在于：数据存在优先级，优先级高的数据会先出。如果优先队列中<strong>数据的（键）值越小，优先级越高</strong>，就称之为<strong>升序优先队列</strong>，反之称为降序优先队列。这里我们考虑升序优先队列。生活中的例子：排队时商家总是先给VIP提供服务，因为他们的优先级更高。</p>
<p>对于优先队列的实现，就不得不提到完全二叉树和二叉堆。</p>
<p>完全二叉树：叶节点只出现在最底层和次底层，且最底层的叶节点都集中在最左边；每个非叶子节点都有两个子节点，最多只有一个例外。</p>
<p>节点3就是唯一的例外，非叶节点的它只有一个子节点</p>
<p>二叉堆（<strong>Heap</strong>）是一种特殊的完全二叉树，它额外拥有堆的性质：<strong>子节点的值一定比父节点大</strong>。这里默认指最小堆（根节点是值最小的节点）。</p>
<p>向二叉堆中插入元素：把待插入元素放在最底层最左边的非空位置，然后冒泡上浮，直到满足堆的性质；删除二叉堆中最小的元素：删除根节点，把最底层最右边的非空位置节点放在根节点，然后冒泡下沉，直到满足堆的性质。以上两个操作的时间复杂度都是 <code>O(log(n))</code></p>
<p>一般采用二叉堆来实现优先队列。新的数据加入优先队列对应着向二叉堆中插入元素；（优先级最高的）数据离开优先队列对应着删除二叉堆中最小的元素。但有一点要注意，优先队列和二叉堆是在概念上完全不同的东西。</p>
<h2 id="Python-中的实现-2"><a href="#Python-中的实现-2" class="headerlink" title="Python 中的实现"></a>Python 中的实现</h2><p>Python 优先队列的底层实现也是二叉堆：<code>queue.PriorityQueue()</code></p>
<h1 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树 BST"></a>二叉搜索树 BST</h1><p>二叉搜索树（Binary Search Tree，BST）是一棵二叉树（每个节点最多有两个子节点）。它的目的是要实现数据快速的增删查改。</p>
<p>它要满足的性质：<strong>左子节点的值比父节点的值要小，右节点的值要比父节点的值大</strong>。在理想的情况下（BST 是平衡的），它增删查改的时间复杂度为 <code>O(logN)</code>；最坏的情况下，BST 退化为链表，时间复杂度为 <code>O(N)</code>。</p>
<img src="https://s2.loli.net/2023/01/29/17ZjQFdEgoSwmut.png" class="">

<p>数据插入的顺序会直接影响 BST 的平衡程度，不同的插入顺序会导致树的高度不一样，影响树的查找效率。</p>
<blockquote>
<p>基于这个问题，平衡二叉搜索树（Balanced BST）产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在 logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树追求全局平衡，导致插入和删除性能差，在实际应用中不如追求局部平衡的红黑树（Red-Black Tree，RBTree）。Java 中的 TreeMap 和TreeSet，C++ STL的map、multimap、multiset等，都用到了 RBTree 取代过长的链表。</p>
</blockquote>
<p><strong>红黑树的查找、插入、删除复杂度均可以保证 <code>O(log n)</code> 的时间复杂度</strong>。至于红黑树的工作原理，<a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a> 这一篇讲得很清晰。</p>
<h2 id="Python-中的实现-3"><a href="#Python-中的实现-3" class="headerlink" title="Python 中的实现"></a>Python 中的实现</h2><p>Python 官方内置库并没有实现树一类的结构，如二叉搜索树、AVL树、红黑树等。网络上有一些讨论过原因，见：<a href="https://stackoverflow.com/questions/17857496/built-in-binary-search-tree-in-python">Built-in binary search tree in Python?</a></p>
<p>但有不少第三方库高效地实现了类似的数据结构。<code>sortedcontainers</code> 就是一个不错的库。它实现了 Sorted List, Sorted Dict, Sorted Set 三种有序数据结构（增删改查的时间复杂度也是 O(log n) 级别），并且在LeetCode下可以直接使用。在个人开发环境中，通过 <code>pip install sortedcontainers</code> 安装即可。</p>
<p>API 可以参考：<a href="https://grantjenks.com/docs/sortedcontainers/">Python Sorted Containers</a></p>
<h1 id="Python-数据结构的性能"><a href="#Python-数据结构的性能" class="headerlink" title="Python 数据结构的性能"></a>Python 数据结构的性能</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>官方解释器CPython中，<code>list</code> 是通过C语言里的<strong>可变长度数组</strong>实现的。这个数组存储的是该 <code>list</code> 中每个元素的引用。数组中的数据在内存空间中是连续的，所以访问 <code>list</code> 中的某个下标所需时间与 <code>list</code> 长度无关，与下标大小也无关。</p>
<img src="https://s2.loli.net/2023/01/29/Ex8jyHGOYCl9mcN.png" class="">

<p>上图是官方网站 <a href="https://wiki.python.org/moin/TimeComplexity">TimeComplexity - Python Wiki</a> 给出的 <code>list</code> 各种操作的时间复杂度。可以看到，在末尾增删数据时，时间复杂度为常数；但一般的增删操作平均需要 <code>O(n)</code> 的复杂度；检查是否包含某个数据，也要 <code>O(n)</code> 的复杂度； 但修改某下标处的数据只需要常数的时间复杂度。</p>
<p>正如前面所说，红黑树的查找、插入、删除复杂度均可以保证 O(log n) 的时间复杂度<strong>。</strong>由此可见，<code>list</code> 与红黑树各有优劣。具体选择哪种数据结构，还是要看增删改查哪些操作用得更多一些。</p>
<h2 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h2><p>CPython中，<code>dictionary</code> 是通过C语言里的<strong>可变长度哈希表</strong>实现的。如果字典里的 key 的哈希值各不相同，那么访问字典中某个 key 的 value 所花费时间是常数，不取决于字典大小。</p>
<img src="https://s2.loli.net/2023/01/29/YWwZmHtVyB64NoC.png" class="">

<blockquote>
<p>The Average Case above assume that the hash function for the objects is sufficiently robust to make collisions uncommon.</p>
</blockquote>
<p>以上的平均时间复杂度基于一个假设：哈希碰撞并不常见。否则，改、查等操作的复杂度会更高，取决于哈希碰撞的频率。</p>
<hr>
<h1 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图 Graph"></a>图 Graph</h1><p>图是另外一种非线性数据结构，它由节点和边组成。图是一个非常大的话题，光分类就有很多种：有向图与无向图、带权重图与无权重图、有环图与无环图等等。这里不详细展开了。</p>
<p>图在生活中随处可见：交通网络、互联网、社交网络的关系网等都可以方便地用图来表示。一些最短路径的算法，如经典的 Dijkstra 算法、A* 算法等都是基于图的算法。还有一些基于图的神经网络，如 GCN（Graph Convolutional Network）、GAT（graph attention network）等。</p>
<p>Python 中 <code>networkx</code> 是一个优秀的开源第三方库，为图的生成、可视化、修改提供了强大的API。</p>
]]></content>
      <categories>
        <category>Python 深耕</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 设计模式</title>
    <url>/posts/47d2101d/</url>
    <content><![CDATA[<h1 id="开篇总领"><a href="#开篇总领" class="headerlink" title="开篇总领"></a>开篇总领</h1><p>设计模式是一种编程思路，对于面向对象的语言，比如 Java, Python 是通用的。但在具体实现中，由于各个语言的特性不同，某些设计模式可能不再需要了。</p>
<p>一般只有在大框架中，设计模式才能更好地发挥作用。平时交个Python作业，设计模式可能用武之地不大，但了解一些设计模式的知识，还是有助于写出比较优雅的代码，增强可维护性。另外，了解设计模式的知识，可以在阅读大的开源项目源码时，更好地梳理开发者的思路。</p>
<p>最后谨记，了解这些只是第一步，接下来要在实践中不断应用，才能烂熟于心。</p>
<blockquote>
<p>本文中的代码例子来自 <a href="https://www.bilibili.com/video/BV19541167cn?p=1">Python 常用设计模式</a></p>
</blockquote>
<hr>
<h1 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h1><p>SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）是在21世纪早期引入的程序设计原则，它加强了程序的<strong>易维护性和可扩展性</strong>。</p>
<ul>
<li><strong>单一职责原则</strong></li>
</ul>
<p>一个类应该只负责一项职责——应该只存在一个使得类变更的原因。（甲类负责两个不同的职责：职责A和B。当职责A需求发生改变而需要修改甲类时，可能导致原本运行正常的职责B发生故障。这种情况说明职责A和B被耦合在了一起，是一种糟糕的设计）</p>
<ul>
<li><strong>开放封闭原则</strong></li>
</ul>
<p>类、模块和函数等应该对扩展开放，对修改关闭（open to extension, close to modification）。即，应该在尽量不修改原代码的前提下进行扩展。</p>
<ul>
<li><strong>里氏替换原则</strong></li>
</ul>
<p>一个对象在其出现的任何地方，都可以用其子类实例做替换，并且不会导致程序的错误。很容易理解，一个子类的实例，必然也是它父类的实例。</p>
<ul>
<li><strong>依赖倒置原则</strong></li>
</ul>
<p>高层模块不应该依赖底层模块（底层实现算法的修改，不应该影响高层模块的调用），二者都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。要针对接口编程，而不是针对实现细节编程。</p>
<p>这里的“抽象”指 Python 的抽象类，它负责定义接口——即子类应该实现哪些函数，参数形式是什么。对应着Java中的 Interface.</p>
<ul>
<li><strong>接口隔离原则</strong></li>
</ul>
<p>使用多个专门的接口，而不使用单一的总接口，子类不应该被强迫实现一些他们不会使用的接口。子类可以通过多继承的方式实现多个细分的接口。</p>
<hr>
<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式是一些创建对象时采用的模式。主要有简单工厂模式、工厂模式、抽象工厂模式、建造者模式、单例模式等。通常情况下，设计从简单工厂模式或工厂模式开始；如果发现需要更多的灵活性和更复杂的应用场景，再考虑抽象工厂模式、建造者模式。</p>
<p>单例模式是为了保证一个类只有一个实例，可以通过重写 <code>__new__</code> 方法实现，这里不展开。可参考视频：<a href="https://www.bilibili.com/video/BV19541167cn/?p=7">Python常用设计模式——单例模式</a></p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>思路：不直接向调用者暴露对象创建的细节，而是通过一个工厂类来负责创建产品类的实例。</p>
<p>简单工程模式的角色有：工厂角色、抽象产品角色、具体产品角色。</p>
<p>首先定义一个抽象类，规定所有的接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象类（目标接口）————抽象产品角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>具体产品继承这个抽象类，实现接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体产品角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alipay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        print(<span class="string">&quot;支付宝余额支付了&#123;0&#125;元!&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体产品角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WechatPay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        print(<span class="string">&quot;微信支付了%d元!&quot;</span> % (money))</span><br></pre></td></tr></table></figure>
<p>接下来定义工厂类，隐藏对象创建的细节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self, method</span>):</span></span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&#x27;Alipay&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> Alipay()</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&#x27;WechatPay&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> WechatPay()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;No such payment named %s&#x27;</span> % method)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端调用。不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例</span></span><br><span class="line">pf = PaymentFactory()</span><br><span class="line">p = pf.create_payment(<span class="string">&#x27;Alipay&#x27;</span>)</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>简单工厂模式只创建一个工厂类，当有新的产品时，需要修改工厂类代码。这违反了“单一职责原则”。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式思路：定义一个抽象的工厂类，让它的子类决定去实例化哪一个产品类。角色有抽象工厂角色、具体工厂角色、抽象产品角色和具体产品角色。</p>
<p>这样的话，每个具体产品对应一个具体的工厂类，遵循了单一职责原则。但是每增加一个具体产品类，就必须增加一个相应的具体工厂类，代码会变得很庞大。</p>
<p>还是上面的例子。这次先定义一个抽象工厂类，规定具体工厂类的接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 抽象工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentFactory</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>然后为每一个产品实现一个具体工厂：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlipayFactory</span>(<span class="params">PaymentFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Alipay()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WechatPayFactory</span>(<span class="params">PaymentFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> WechatPay()</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = WechatPayFactory().create_payment()</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h2 id="抽象工厂模式-amp-建造者模式"><a href="#抽象工厂模式-amp-建造者模式" class="headerlink" title="抽象工厂模式 &amp; 建造者模式"></a>抽象工厂模式 &amp; 建造者模式</h2><p>相比工厂方法模式，抽象工厂模式中的每一个具体工厂都生产一套产品。注重产品的组装，考虑了不同产品之间的约束关系。</p>
<p>建造者模式则着重考虑产品的组装顺序，对构造过程有着更精细的控制。</p>
<p>例子可以参考这个 Github 上的笔记：<a href="https://github.com/ThanlonSmith/design-pattern/blob/master/3.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.md">创建型模式.md</a></p>
<hr>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a><strong>结构型模式</strong></h1><p>结构型模式主要研究几个类之间如何协同使用。其中适配器模式和代理模式一般应用在和其他项目对接过程中，不方便更改原代码，而进行的打补丁操作。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><strong>适配器模式</strong></h2><p>这个模式不是用在项目设计阶段的，而是用来整合多个项目。目标是使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。实现适配器的两种方式，<strong>类适配器使用多继承，对象适配器使用组合</strong>（组合就是把一个类的对象作为属性放入另一类中）。</p>
<p>假如现在有一些类已经继承了目标接口。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支付功能的抽象类（目标接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span>(<span class="params"><span class="built_in">object</span>, metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 已经继承了目标接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alipay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;支付宝支付%d元&#x27;</span> % money)</span><br></pre></td></tr></table></figure>
<p>但有其他项目中有一些类的接口不一致——<code>cost</code> 与 <code>pay</code> 不一致。（实际场景中，不光函数名不一样，参数个数、顺序、返回值类型可能都不一致）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其他项目中接口不一致的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankPay</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;银联支付%d元&#x27;</span> % money)</span><br></pre></td></tr></table></figure>
<p>这个时候可以使用类适配器，<strong>利用多继承，创建一个新的类，统一接口</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentAdapter</span>(<span class="params">Payment, BankPay</span>):</span></span><br><span class="line"><span class="comment">#### 统一接口 ####</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        self.cost(money)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">p = PaymentAdapter()</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>还可以使用对象适配器，<strong>利用组合统一接口</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentAdapter</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, payment</span>):</span></span><br><span class="line">        self.payment = payment</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        self.payment.cost(money)</span><br></pre></td></tr></table></figure>
<p>总结：如果只需要适配一个类的接口，那么类适配器就可以。如果有多个待适配的类，如果用类适配器，需要对每一个待适配的类创建一个新的类；这个时候用对象适配器比较方便。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其它对象提供一种代理以控制对这个对象的访问，相当于在访问对象之前加了一层关卡。</p>
<p>角色有抽象实体、实体和代理。实体和代理都要继承抽象实体，以对外界实现同样的调用接口。可以通过代理控制访问权限、优化流程等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_content</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>(<span class="params">Subject</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        print(<span class="string">&#x27;读取文件内容！&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.content = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_content</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br></pre></td></tr></table></figure>
<p>每次创建 <code>RealSubject</code> 的时候就会读取文件。如果文件特别大，我们希望只在调用 <code>get_content</code> 方法时再读取文件该怎么办？（当然可以直接修改 RealSubject 的代码，但这里考虑的是无权做这样的修改）可以使用一个虚代理，对 RealSubject 的功能进行“重组”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualProxy</span>(<span class="params">Subject</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.subj = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.subj:</span><br><span class="line">            self.subj = RealSubject(self.filename)</span><br><span class="line">        <span class="keyword">return</span> self.subj.get_content()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_content</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.subj:</span><br><span class="line">            self.subj = RealSubject(self.filename)</span><br><span class="line">        <span class="keyword">return</span> self.subj.set_content(content)</span><br></pre></td></tr></table></figure>
<p>虚代理中，只有在调用 <code>get_content</code> 方法时，才会真正读取文件，节省了内存的开销。这就好比手机开流量节省模式，不自动加载图片，除非收到明确加载的指令。</p>
<p>除此之外，当然也可以控制访问权限：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtectedSubject</span>(<span class="params">Subject</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        self.subj = RealSubject(filename)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.subj.get_content()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_content</span>(<span class="params">self, content</span>):</span></span><br><span class="line"><span class="comment">#### 检查权限</span></span><br><span class="line">        <span class="keyword">raise</span> PermissionError(<span class="string">&#x27;无写入权限！&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>看下来，代理模式有点类似于装饰器。只不过装饰器一般用来加强功能，而代理模式一般用来保持接口不变的前提下，“重组”现有的功能，以优化流程或进行控制。</p>
<h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><p>桥模式是将一个事物的两个属性分离，使其都可以独立地变化、方便地扩展。它使用松耦合的方式绑定两个属性。</p>
<p>与之相对的，为每个可能的属性组合定义一个专门的类，是紧耦合。这种方式不可取，可扩展性极差。比如这个例子，有形状、颜色两个维度的属性。如何定义具有这两个属性的物体呢？——为每一种形状、每一种颜色的物体定义一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>(<span class="params">Shape</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>(<span class="params">Shape</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 紧耦合。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedRectangle</span>(<span class="params">Rectangle</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedCircle</span>(<span class="params">Circle</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenCircle</span>(<span class="params">Circle</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>如果要增加颜色或形状，那么类的数量会指数级增加。</p>
<p>我们来看看松耦合的一种实现思路：把继承抽象类 <code>Color</code> 的类（如 <code>Red</code>, <code>Green</code>）的实例传入抽象类 <code>Shape</code>；继承 <code>Shape</code> 的子类就有了颜色的实例，可以访问它的属性和方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, color</span>):</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 细化抽象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>(<span class="params">Shape</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;长方形&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.color.paint(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要扩展形状，只需要添加形状类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>(<span class="params">Shape</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;圆形&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.color.paint(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 细化实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span>(<span class="params">Color</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;画红色的%s&#x27;</span> % shape.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要扩展颜色，只需要添加颜色类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Green</span>(<span class="params">Color</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;画绿色的%s&#x27;</span> % shape.name)</span><br><span class="line"></span><br><span class="line">rectangle = Rectangle(Red())</span><br><span class="line">rectangle.draw() <span class="comment">### 画红色的长方形</span></span><br><span class="line">circle = Circle(Green())</span><br><span class="line">circle.draw() <span class="comment">### 画绿色的圆形</span></span><br></pre></td></tr></table></figure>
<p>桥模式的松耦合，用到了“组合”（把一个类的对象作为属性放入另一类中）。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式把子系统中的一组接口封装起来，提供一个高层的接口，方便子系统的调用。减少系统相互依赖，提高灵活性，提高了安全性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;CPU start to run...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;CPU stop to run...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Disk start to run...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Disk stop to run...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外观</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.CPU = CPU()</span><br><span class="line">        self.Disc = Disk()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.CPU.run()</span><br><span class="line">        self.Disc.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.CPU.stop()</span><br><span class="line">        self.Disc.stop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端，高层代码</span></span><br><span class="line">c = Computer()</span><br><span class="line">c.run()</span><br><span class="line">c.stop()</span><br></pre></td></tr></table></figure>
<p>外观模式的核心思想就是封装。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>看一个例子：做PPT的时候，需要把多个图形组合成一个图形。这个组合图形（组合对象）的操作与单个图形（叶对象）的操作是一样的。组合图形与单个图形、组合图形之间都可以继续组合。</p>
<p>组合模式如何应用？先定义一个抽象组件。后续的叶对象、组合对象都是它的子类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>然后可以定义一些叶子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 叶子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">Graphic</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;点(%s,%s)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叶子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>(<span class="params">Graphic</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, p1, p2</span>):</span></span><br><span class="line">        self.p1 = p1</span><br><span class="line">        self.p2 = p2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;线段[(%s,%s)]&#x27;</span> % (self.p1, self.p2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self)</span><br></pre></td></tr></table></figure>
<p>以及组合类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复合组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span>(<span class="params">Graphic</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterable</span>):</span></span><br><span class="line"><span class="comment">#### 用可遍历的容器初始化，容器中元素是抽象组件 Graphic 的子类实例</span></span><br><span class="line">        self.children = []</span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> iterable:</span><br><span class="line">            self.add(g)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, graphic</span>):</span></span><br><span class="line">        self.children.append(graphic)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="comment">#### 递归地调用它的 children</span></span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> self.children:</span><br><span class="line">            g.draw()</span><br></pre></td></tr></table></figure>
<p>客户端调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">l1 = Line(Point(<span class="number">1</span>, <span class="number">2</span>), Point(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复合图形</span></span><br><span class="line">pic = Picture([p, l1])</span><br><span class="line">pic2 = Picture([pic, l2])</span><br><span class="line">pic2.draw()</span><br></pre></td></tr></table></figure>
<p>组合模式的核心思路：利用多态，让组合对象和叶对象的对外接口保存一致。表示出 “部分-整体” 的层次结构，生成树状结构。调用顶层对象时，会递归地遍历其下的叶对象执行。</p>
<hr>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>多个对象都有机会处理请求时，将这些对象连成一条链并沿着这条链传递该请求，直到有一个对象处理它为止；从而避免请求的发送者和接收者之间的耦合关系。</p>
<p>责任链的角色有抽象处理者、具体处理者和客户端。举个例子，有一个请假的请求，不同级别的主管有不同的批准权限；要逐级地向上传递该请求，直到有人能处理为止。</p>
<p>先定义一个抽象的处理者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象的处理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_leave</span>(<span class="params">self, day</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>再来定义项目主管、部门经理、总经理三个不同级别的具体处理者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体的处理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span>(<span class="params">Handler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_leave</span>(<span class="params">self, day</span>):</span></span><br><span class="line">        <span class="keyword">if</span> day &lt;= <span class="number">30</span>:</span><br><span class="line">            print(<span class="string">&#x27;总经理准假%d&#x27;</span> % day)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;可以辞职了！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体的处理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepartmentManager</span>(<span class="params">Handler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = GeneralManager()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_leave</span>(<span class="params">self, day</span>):</span></span><br><span class="line">        <span class="keyword">if</span> day &lt;= <span class="number">7</span>:</span><br><span class="line">            print(<span class="string">&#x27;项目主管准假%d&#x27;</span> % day)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;部门经理职权不足&#x27;</span>)</span><br><span class="line">            self.<span class="built_in">next</span>.handle_leave(day)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体的处理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectDirector</span>(<span class="params">Handler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = DepartmentManager()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_leave</span>(<span class="params">self, day</span>):</span></span><br><span class="line">        <span class="keyword">if</span> day &lt;= <span class="number">3</span>:</span><br><span class="line">            print(<span class="string">&#x27;项目主管准假%d&#x27;</span> % day)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;项目主管职权不足&#x27;</span>)</span><br><span class="line">            self.<span class="built_in">next</span>.handle_leave(day)</span><br></pre></td></tr></table></figure>
<p>可以看到，级别低的对象有一个 <code>next</code> 属性， 存储一个更高级别的对象。当前对象权限不足以处理该请求时，它会调用 <code>next</code> 对象的处理方法，直到该请求被处理，或者到达最高级别对象，在该例子中就是总经理。</p>
<p>高层代码调用时，只需要对最低级别的对象发出请求即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">day = <span class="number">20</span></span><br><span class="line">p = ProjectDirector()</span><br><span class="line">p.handle_leave(day)</span><br></pre></td></tr></table></figure>
<p>责任链模式使用场景：有多个对象可以处理一个请求，而具体哪个对象处理则在运行时决定。优点是降低了耦合度，无需知道是哪一个对象处理了请求。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式应用非常广泛，又被称为“发布-订阅”模式。它用来定义对象间<strong>一对多的依赖关系：</strong>当一个对象的状态发生变化时，所有依赖它的对象都得到通知并被自动更新。</p>
<p>观察者模式的角色有：抽象主题、具体主题（发布者）、抽象观察者和具体观察者（订阅者）。这里举一个公司向员工发布公告的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象的订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, notice</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象的发布者。这里不是一个抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notice</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, obs</span>):</span></span><br><span class="line">        self.observers.append(obs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span>(<span class="params">self, obs</span>):</span></span><br><span class="line">        self.observers.remove(obs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> obs <span class="keyword">in</span> self.observers:</span><br><span class="line">            obs.update(self)</span><br></pre></td></tr></table></figure>
<p>然后定义公司是一个具体的发布者；员工是一个具体的观察者。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体的发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaffNotice</span>(<span class="params">Notice</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, company_info</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类对象声明observers属性</span></span><br><span class="line">        self.__company_info = company_info</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">company_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__company_info</span><br><span class="line"></span><br><span class="line"><span class="meta">    @company_info.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">company_info</span>(<span class="params">self, info</span>):</span></span><br><span class="line">        self.__company_info = info</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体的订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span>(<span class="params">Observer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.company_info = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, notice</span>):</span></span><br><span class="line">        self.company_info = notice.company_info</span><br></pre></td></tr></table></figure>
<p>这里的关键在于，在 <code>StaffNotice</code> 里面定义了私有属性 <code>company_info</code>。在这个私有属性的 <code>setter</code> 方法里，调用了 <code>self.notity()</code>。也就是说，<strong>每当信息被更新时，都会自动推送给订阅者</strong>。而订阅者可以通过一个列表维护，方便添加和移除。</p>
<p>调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">staff_notice = StaffNotice(<span class="string">&#x27;初始化公司信息&#x27;</span>)</span><br><span class="line">staff1 = Staff()</span><br><span class="line">staff2 = Staff()</span><br><span class="line">staff_notice.attach(staff1)</span><br><span class="line">staff_notice.attach(staff2)</span><br><span class="line">staff_notice.company_info = <span class="string">&#x27;假期放假通知！&#x27;</span></span><br><span class="line"><span class="comment">#### 只要staff_notice更新了信息，列表中的staff1 和staff2 会自动接受到 ####</span></span><br><span class="line">print(staff1.company_info)</span><br></pre></td></tr></table></figure>
<p>使用场景就想象订阅微信公众号就行了：一个对象的改变需要同时改变其它对象，但事先不知道具体有多少对象待改变。换言之，我们不希望这些对象是紧耦合的，可以灵活地订阅和取关。优点：发布者与观察者之间的耦合最小；支持广播通信。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>定义一个算法骨架，将一些具体实现步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span>  <span class="comment"># 原子操作/钩子操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repaint</span>(<span class="params">self</span>):</span>  <span class="comment"># 原子操作/钩子操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span>  <span class="comment"># 原子操作/钩子操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 模板方法，算法的抽象框架 ####</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.start()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.repaint()</span><br><span class="line">                sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.stop()</span><br></pre></td></tr></table></figure>
<p><code>run</code>提供了算法的抽象框架。子类只需要实现那些“原子操作”即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span>(<span class="params">Window</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;窗口开始运行！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;窗口停止运行！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repaint</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.msg)</span><br><span class="line"></span><br><span class="line">MyWindow(<span class="string">&quot;Hello...&quot;</span>).run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>适用场景：一次性实现一个算法的不变部分，各个子类中的公共行为被提取出来并集中到一个公共父类中以避免代码重复。也可以控制子类的扩展，统一接口。</p>
<hr>
<p>所谓“师傅领进门，修行在个人”。现在感觉像是一名学过剑术的入门弟子，但毫无实战经验。此时距离一名侠客还有很远，唯有在江湖漂泊中身经百战，不断领悟剑术中的奥妙，才能人剑合一。</p>
]]></content>
      <categories>
        <category>Python 深耕</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>读《阴符经》——观天之道，执天之行</title>
    <url>/posts/58ced77a/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>《黄帝阴符经》，简称《阴符经》，后人依托黄帝所作，成书年代不详，唐代始通行于世，言行事暗合天道，切应盗机，则能功成事遂。洞察世间细微变化的内心感应称为“阴”；万物变化自然而然，这个道理称为“符”。<strong>隐微难见称之为阴，妙合大道称之为符</strong>，是所谓《阴符经》。</p>
<p>《阴符经》历代注家解经要旨不一，或以为兵家权谋之书，或解以道家之言，宋元道士多以内丹功法注经，文人则以儒家性理之说释之。作为道教的一部重要道经，《阴符经》迄清代已逾百家注解，其重要性不下于《道德经》和《南华真经》。——维基百科</p>
<p>据说《阴符经》是唐代李筌在河南境内嵩山少室虎口岩石壁中发现的，此后才传抄流行于世。李筌得到经文后，为它作了注——《黄帝阴符经疏》。这是一个流行的注解版本，但唐代著名道士张果（八仙之一“张果老”的原型）对李筌的注解不屑一顾，说他“何昧之至”、“诬道之甚”。</p>
<p>《战国策》中记载，苏秦游说秦国失败，引锥刺股苦读《阴符经》，终有所成。</p>
<blockquote>
<p>归至家，妻不下纴，嫂不为炊。父母不与言。苏秦喟叹曰：“妻不以我为夫，嫂不以我为叔，父母不以我为子，是皆秦之罪也。”乃夜发书，陈箧数十，得太公《阴符》之谋，伏而诵之，简练以为揣摩。读书欲睡，引锥自刺其股，血流至足，曰：“安有说人主，不能出其金玉锦绣，取卿相之尊者乎？”期年，揣摩成，曰：“此真可以说当世之君矣。”——《战国策·苏秦以连横说秦》</p>
</blockquote>
<p>传说中成就苏秦执掌六国相印的《阴符经》，到底是何奇书？虽然我阅历浅薄，读书甚少，但愿意借助张果的注解，以及周观鱼up的讲评，试着去理解一下这部只有三百余字的经文。</p>
<img src="https://s2.loli.net/2023/01/28/LEae2v3VlRIz9WN.png" class="" title="大字《阴符经》">

<p>唐代褚遂良曾写过大字《阴符经》，周观鱼up结合着褚遂良的书法作品，对《阴符经》进行了讲解，推荐移步B站一观：<a href="https://www.bilibili.com/video/BV1tk4y1y7iP/">褚遂良《阴符经》意注黄庭顿悟阴阳妙理，心藏玄钥打开动静机关</a></p>
<h2 id="正文并张果注"><a href="#正文并张果注" class="headerlink" title="正文并张果注"></a>正文并张果注</h2><h3 id="上篇"><a href="#上篇" class="headerlink" title="上篇"></a>上篇</h3><ul>
<li><strong>观天之道，执天之行，尽矣</strong>。</li>
</ul>
<blockquote>
<p>观自然之道，无所观也。不观之以目而观之以心，心深微而无所见，故能照自然之性，唯深微而能照，其斯之谓阴。执自然之行，无所执也，不执之以手而执之以机，机变通而无所系，故能契自然之理，其斯之谓符。照之以心，契之以机，而阴符之义尽矣。李筌以阴为暗，以符为合，以此文为序首，何昧之至也？</p>
</blockquote>
<p>开头一句提纲挈领：用内心感受天地运行的规律，所行之事契合自然之理，“照之以心，契之以机”，这就是全部的奥妙了。</p>
<ul>
<li><strong>故天有五贼，见之者昌</strong>。</li>
</ul>
<blockquote>
<p>五贼者，<strong>命、物、时、功、神</strong></p>
</blockquote>
<p>通常把这一句中的“五贼”释义为五行。但张果老先生解释说，<ins>五贼指的是先天条件（命）、后天物质（物）、合适的时机（时）、强大的助力（功）、天道的眷顾（神）</ins>。这里的“贼”不是指偷盗，而是“逆”的意思。上克下称为克，下克上称为贼。事物发展到一定阶段，出现弊端的时候，就要通过反克的方式，维持天道的运转。看似逆流而上，恰是顺道而行，这便是“反经合道之谋”。圣人对于这种反克的措施很谨慎，称之为“贼”；但天下百姓仰赖这种逆反的措施，称之为“德”，所以“见之者昌”。</p>
<p>这个解释非常有意思，它很好地诠释了《老子》里面说的“<ins>反者道之动</ins>”。很多人认为天道运转无懈可击，但张果说，天道运转并不完美，能够利用“五贼”解决它的弊端，维持天道平衡，就称为“德”。五贼即是五德。用今天的话来说，它蕴含了朴素的辩证唯物主义思想。</p>
<ul>
<li><strong>五贼在乎心，施行乎天。宇宙在乎手，万化生乎身</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：其立德明机用妙，发之于内，见之于外而已，岂称兵革以作寇乱哉？见其机而执之，虽宇宙之大不离乎掌领，况其小者乎？知其神而体之，虽万物之众不能出其胸臆，况其寡者乎？自然造化之力，而我有之，不亦盛乎？不亦大乎？李筌等以五贼为五味，顺之则可以神仙不死，诬道之甚也。</p>
</blockquote>
<p>四方上下曰宇，往来古今曰宙，宇宙便代表了时空的广袤。顺着前面对五贼的理解，这一段就自然而然了。五贼在心，则时空在手，万物归身。天地虽大，其化均也；万物虽多，其治一也。</p>
<ul>
<li><strong>天性，人也。人心，机也。立天之道，以定人也</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：人谓天性机为人心，人性本自玄合，故圣人能体五贼也。</p>
</blockquote>
<p>人的存在就是天性的具体表现形式；而人的内心活动和思维，就是操纵天性的机关。</p>
<ul>
<li><strong>天发杀机，龙蛇起陆。人发杀机，天地反复</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：天机张而不生，天机弛而不死。天有弛张，用有否臧，张则杀威行，弛则杀威亡，天杀之机息。然天以炁为威，人以德为机。秋冬阴炁严凝，天之张杀机也，故龙蛇畏而垫伏；冬谢春来，阴退阳长，天之弛杀也，故龙蛇悦而振起。天亦有寒暄。德亦有寒暄，人亦有寒暄。德刑总肃，君之张杀机也，故臣下畏而服从；德失刑偏，君之弛杀机也，故奸雄悦而驰骋。位有尊卑，如人有天地。故曰；天发杀机，龙蛇起陆，寇乱所由作；人发杀机，天地反复，尊卑犹是革。太公、诸葛亮等以杀人过万，大风暴起，昼若暝，以为天地反复，其失甚矣。</p>
</blockquote>
<p>这里的“杀机”可以理解成反常的行为。天地人总是在规律与反常之间循环往复。杀机弛，则运转如常；杀机张，则事出反常。气候在冰期与间冰期之间循环；大陆板块曾发生移动，后来达到新的平衡，这些可以看作是天地的杀机一张一弛。对于人，大到朝代兴替，小到家门兴衰，也是不断的变化。杀机的张弛有度，就对应着上面说的五贼。</p>
<p>张果先生把杀机张释义为秋冬冷冽，杀机弛释义为冬谢春来，我并不赞同。四季轮转是规律之事，并非反常。</p>
<ul>
<li><strong>天人合发，万变定基</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：天以祸福之机运于上，君以利害之机动于下，故有德者万变而愈盛，以至于王；无德者万化而愈衰，以至于亡。万变定基，自然而定。</p>
</blockquote>
<p>天地人在规律与反常之间来回反复。“有德者万变而愈盛，以至于王；无德者万化而愈衰，以至于亡”。有德与无德的区别，我认为就在于能否利用好“五贼”。</p>
<ul>
<li><strong>性有巧拙，可以伏藏。九窍之邪，在乎三要，可以动静</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：九窍之用，三要为机。三要者，机、情、性也。机之则无不安，情之则无不邪，性之则无不正。故圣人动以伏其情，静以常其性，乐以定其机；小人则反此。故下文云：太公以三要为耳、目、口；李筌为心、神、息，皆忘机也，俱失《阴符》之正意。</p>
</blockquote>
<ul>
<li><strong>火生于木，祸发必克。奸生于国，时动必溃。知之修之，谓之圣人</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：夫木情静，动而生火，不觉火盛而焚其质。由人之性静，动而生奸，不觉奸成而乱其国。夫明者见彼之隙以设其机，智者知彼之病以图其利，则天下之人彼愚而我圣。是谓生者自谓得其生，死者自谓得其死，无不谓得道之理也。</p>
</blockquote>
<p>这一句还是阐释了“反克”的道理。火生于木，却能将其焚毁；国家运转出现问题，会为奸人提供生存土壤，最终被奸人搅动风云，时局动荡、国家溃亡。能够洞察稳定表象背后的乱象，并且实施恰当的手段治理，这才叫圣人。</p>
<p>孔子说，“乡愿，德之贼也”。我认为这也是稳定表象背后的乱象。</p>
<h3 id="中篇"><a href="#中篇" class="headerlink" title="中篇"></a>中篇</h3><ul>
<li><strong>天生天杀，道之理也。天地，万物之盗；万物，人之盗；人，万物之盗。三盗既宜，三才既安</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：天地以阴阳之炁化万物，万物不知其盗；万物以美恶之味飨人，人不知其盗；人以利害之谋制万物，万物不知其盗。三盗玄合于人心，三才顺动于天理。有若时，然后食终身；无不愈时，然后动庶绩，无不安食；不得其时，动不得其机，殆至灭亡。</p>
</blockquote>
<p>万物生长到一定程度，就会面临衰亡，这是自然之理。“盗”是指赖以生存的东西。天地为万物提供赖以生存的资源；人依赖于万物而生存；而万物同时也依赖于人而生存。</p>
<p>关于这“最后一盗”，为什么万物依赖于人而生存呢？一种解释是，人也是万物的一环，虽然生时呼风唤雨，但终将归于尘土，为万物生长提供养料。这妥妥的生物循环系统嘛！另一种解释，则是像张果老先生说的，人制造万物。当然这里的“万物”与第一盗中的“万物”是不同的，它是没有生命的。</p>
<p>“三盗既宜，三才既安”，这一句其实暗合了《孟子》里说的“不违农时，谷不可胜食也；数罟不入洿池，鱼鳖不可胜食也；斧斤以时入山林，材木不可胜用也”。要求人们按自然规律行事，才能安得其食。</p>
<ul>
<li><strong>故曰：食其时，百骸理。动其机，万化安。人知其神而神，不知其不神所以神也</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：时人不知盗之为盗，只谓神之能神。鬼谷子曰：彼此不觉之谓神，盖用微之功著矣。李筌不知此文意通三灵，别以圣人愚人为喻，何甚失也？</p>
</blockquote>
<p>人们知道遵循自然之道就能稳定平衡的道理，但人们不知道遵循自然之道这件事，都是在日常微不足道的小事中进行的。“彼此不觉之谓神，盖用微之功著矣”。</p>
<ul>
<li><strong>日月有数，大小有定。圣功生焉，神明出焉</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：日月有准，运数也。大小有定，君臣也。观天之时，察人之事，执人之。机，如是则圣得以功，神得以明，心宜理合，安之善也。筌以度数为日月，以馀分为大小，以神炁能生圣功神明，错谬之甚也。</p>
</blockquote>
<ul>
<li><strong>其盗机也，天下莫能见，莫能知也。君子得之固躬，小人得之轻命</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：其盗微而动，所施甚明博，所行极玄妙。君子用之，达则兼济天下，太公其人也；穷则独善其一身，夫子其人也，岂非择利之能审？小人用之，则失其身，大夫种之谓欤？得利而亡义，李斯之谓欤？岂非信道之不笃焉？</p>
</blockquote>
<p>“盗机”指的对天地人生存资源的掌控。君子得之，兼济天下，不违初心。小人得之，谋取私利，不惜失命。</p>
<h3 id="下篇"><a href="#下篇" class="headerlink" title="下篇"></a>下篇</h3><ul>
<li><strong>瞽者善听，聋者善视，绝利一源，用师十倍；三返昼夜，用师万倍</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：瞽者善于听，忘色审声，所以致其听；聋者善于视，遗耳专目，所以致其明。故能十众之功，一昼之中三而行之，所以至也；一夜之中三而息之，所以精也。故能用万众之人。荃不知师是众，以为兵师，误也。</p>
</blockquote>
<p>“绝利一源，用师十倍”：如果人把精力修为都集中在某一方面，就会产生超常的能力，譬如视力功能障碍的人听力非常敏锐、听力功能障碍的人眼光非常犀利。</p>
<ul>
<li><strong>心生于物，死于物，机在于目</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：夫心有爱恶之情，物有否臧之用。目视而察之于外，心应而度之于内。善则从而行之，否则达而止之，所以观善而惩恶也。筌以项羽其目机，心生于物，以符坚见机，心死于物，殊不知有否臧之用。</p>
</blockquote>
<p>“人动生妄心于物者，皆由目睹而心生，故云：机在目”。</p>
<ul>
<li><strong>天之无恩而大恩生。迅雷烈风，莫不蠢然</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：天以凶象咎征见，人能儆戒以修德。以迅雷烈风动人之恐惧，以政福无恩而生大恩之谓也。李筌以天地不仁为大恩，以万物归于天为蠢然，与《阴符》本意殊背。</p>
</blockquote>
<p>天地出现异常现象，实际上是在警示人们，看起来“天地不仁”、“天之无恩”，但这已经是极大的恩赐了。可以结合当代的气候变化、异常天气等理解这一点。</p>
<ul>
<li><strong>至乐性馀，至静性廉</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：未发谓之中，守中谓之常，别乐得其志，而性有馀矣。安常谓之自足，则静其志而廉常足矣。筌以奢为乐性，以廉为静，殊乖至道之意。</p>
</blockquote>
<ul>
<li><strong>天之至私，用之至公。擒之制在炁</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：自然之理微而不可知，私之至也；自然之效明而不可违，公之至也。体圣体之亦然。筌引《孙子》云：视卒如爱子，可以之俱死。何也？</p>
</blockquote>
<p>天道运行的规律十分隐秘，而运行的效果施于所有人。“擒”，捕获。要想捕捉天道运行的规律，就要知道，它无非是气的流转运行而已。</p>
<ul>
<li><strong>生者，死之根；死者，生之根。恩生于害，害生于恩</strong>。</li>
</ul>
<blockquote>
<p>生者，人之所爱厚，于身大过，则道丧而死自来矣。死者，人之所恶，于事至明，则道在而生自图矣。福理所及谓之恩，祸乱所及谓之害，损己则为物之所益，害之生恩也。筌引孙子用兵为生死，丁公、管仲为恩害，异哉？</p>
</blockquote>
<p>生死互根，恩害转换，循环往复，也无悲喜。命书《滴天髓》中有这么一句：“有情却被人离间，怨起恩中死不灰”。</p>
<ul>
<li><strong>愚人以天地文理圣，我以时物文理哲。人以愚虞圣，我以不愚虞圣，人以奇其圣，我以不奇其圣。故曰：沉水入火，自取灭亡</strong>。</li>
</ul>
<blockquote>
<p>《传》曰：观天之运四时，察地之化万物，无所不知而蔽之以无知，小恩于人以蒙自养之谓也。知四时之行，知万物之生，皆自然也。故圣人于我以中自居之谓也，故曰死生在我而已矣。人之死亡，譬如沉水自溺，投火自焚，自取灭亡。理国以道，在于损其事而已；理军以权，在于亡其兵而已。无死机则不死，鬼神其如我何？天生机则不生，天地其如我何？圣人修身以安其家，理国以平天下，在乎立生机以自去其死性者，生之机也；除死机以自取其生情者，死之机也。筌不了天道，以愚人。圣人体道，愚昧之人而验天道，失之甚也。</p>
</blockquote>
<p>愚人只从表面学习了一些知识，就自认为是圣人；要成为真正的圣哲，需亲自体会万事万物的细微变化，借此体会其中蕴含的规律道理。</p>
<p>另外很多人把哗众取宠的欺诈行为当作真理，我却认为只有朴实无华才是大道。</p>
<p>圣人总被人们认为是无所不能的神化人格，我却认为真正的圣人是那些默默成就万物而无功名之人。这与庄子《逍遥游》中的“至人无己，神人无功，圣人无名”相契合。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>《阴符经》蕴含着很多辩证唯物主义思想，仔细读来很有趣。我最喜欢的三句是：“<strong>故天有五贼，见之者昌</strong>”、“<strong>火生于木，祸发必克</strong>”、“<strong>人以奇其圣，我以不奇其圣</strong>”。</p>
<p>随着时间推移和阅历增长，对于某些句子的理解肯定会不同。常读常新，这次就当一个底稿，容我之后再来补充。</p>
<p>像这种中国古代的经文典籍，虽然读起来很玄乎，动不动就“宇宙在乎手，万化生乎身”，但如果仔细推敲，会发现古人的精神境界之高。尽管古代的科技水平和生产力不可与现代同日而语，尽管已经时迁事异，但人的精神内核是不变的，古今的情感是相通的。“自其不变者而观之，则物与我皆无尽也”，指的便是精神与情感的连结。</p>
<p>“人事有代谢，往来成古今。 江山留胜迹，我辈复登临”孟浩然的这句诗总令我不胜唏嘘。中华文化留下的，不只是江山胜迹，还有经文典籍。背靠浩如烟海的精神财富，我很幸运，也很幸福。</p>
<p>2022.12.5于巴黎。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>道家</tag>
      </tags>
  </entry>
</search>
